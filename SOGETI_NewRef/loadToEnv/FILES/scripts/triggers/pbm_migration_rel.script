getLogger("import.rel").loggerWarn("debut de script de chargement realtionships");

var defaultMessageMap = [];

var CSV_DEFAULT_LKT_HIERARCHY = getStringValueForClassMember("com.ibm.ccd.common.migration.to52.EnvImportExportHelper", "CSV_DEFAULT_LKT_HIERARCHY");//"##DefaultLookupTableHierarchy##";
var CSV_DEFAULT_SPEC = getStringValueForClassMember("com.ibm.ccd.common.migration.to52.EnvImportExportHelper", "CSV_DEFAULT_SPEC");//"##DefaultHierarchyPrimarySpec##";
var CSV_DEFAULT_SPEC_ATTR_NAME = getStringValueForClassMember("com.ibm.ccd.common.migration.to52.EnvImportExportHelper", "CSV_DEFAULT_SPEC_ATTR_NAME");//"##NAME##";
var CSV_DEFAULT_SPEC_ATTR_PATH = getStringValueForClassMember("com.ibm.ccd.common.migration.to52.EnvImportExportHelper", "CSV_DEFAULT_SPEC_ATTR_PATH");//"##PATH##";
var CSV_DEFAULT_SPEC_ATTR_DISPLAYNAME = getStringValueForClassMember("com.ibm.ccd.common.migration.to52.EnvImportExportHelper", "CSV_DEFAULT_SPEC_ATTR_DISPLAYNAME");//"##DISPNAME##";


//Retrive Default Locale object
var getDefaultLocale = createJavaMethod("com.ibm.ccd.common.context.common.LocaleContext","getDefaultLocale");
var defaultLocale = runJavaMethod(null,getDefaultLocale);


//create getMessage method 
var getMessage = createJavaMethod("com.ibm.ccd.common.context.common.LocaleContext","getMessage","java.lang.String","java.util.Locale");

var strvalue = getStringValueForClassMember("com.ibm.ccd.common.util.Const", "DEFAULT_LOOKUP_TABLE_HIERARCHY_NAME_INDEX");
var DEFAULT_LKT_HIERARCHY = runJavaMethod(null,getMessage,strvalue, defaultLocale);
defaultMessageMap[CSV_DEFAULT_LKT_HIERARCHY]=DEFAULT_LKT_HIERARCHY;

strvalue = getStringValueForClassMember("com.ibm.ccd.common.util.Const", "DEFAULT_HIERARCHY_SPEC_NAME_INDEX");
var DEFAULT_SPEC = runJavaMethod(null,getMessage,strvalue, defaultLocale);
defaultMessageMap[CSV_DEFAULT_SPEC]=DEFAULT_SPEC;

strvalue = getStringValueForClassMember("com.ibm.ccd.common.util.Const", "DEFAULT_HIERARCHY_SPEC_PRIMARY_KEY_FIELD_NAME_INDEX");
var DEFAULT_SPEC_ATTR_NAME = runJavaMethod(null,getMessage,strvalue, defaultLocale);
defaultMessageMap[CSV_DEFAULT_SPEC_ATTR_NAME]=DEFAULT_SPEC_ATTR_NAME;

strvalue = getStringValueForClassMember("com.ibm.ccd.common.util.Const", "DEFAULT_HIERARCHY_SPEC_PATH_FIELD_NAME_INDEX");
var DEFAULT_SPEC_ATTR_PATH = runJavaMethod(null,getMessage,strvalue, defaultLocale);
defaultMessageMap[CSV_DEFAULT_SPEC_ATTR_PATH]=DEFAULT_SPEC_ATTR_PATH;

strvalue = getStringValueForClassMember("com.ibm.ccd.common.util.Const", "DEFAULT_HIERARCHY_SPEC_DISPLAY_NAME_FIELD_NAME_INDEX");
var DEFAULT_SPEC_ATTR_DISPLAYNAME = runJavaMethod(null,getMessage,strvalue, defaultLocale);
defaultMessageMap[CSV_DEFAULT_SPEC_ATTR_DISPLAYNAME]=DEFAULT_SPEC_ATTR_DISPLAYNAME;

function replaceCSVDefaults(str,msgMap)
{
  if( (str == null) || (str.indexOf("##") == -1) )
  {
  	return str;
  }
  var key;
  var value;
  forEachHmElement(msgMap, key, value) 
  {
	  str = replaceString(str,key,value);
  }
  
  return str;
}




var delim = "~~~~~";

var ctg = getCtgByName();
var relatedCatalogs = [];

var processingOptions = [];
processingOptions[0] = "ALL";
ctg.disableContainerProcessingOptions(processingOptions);

// propagate processing options to the EntryPopulator
var mGetContainer = createJavaMethod("com.ibm.ccd.element.interfaces.IContainer", "getEntryPopulator");		
var objEntryPopulator = runJavaMethod(ctg, mGetContainer);
var mRecalculateValidateOptions = createJavaMethod("com.ibm.ccd.element.common.EntryPopulator",
			"recalculateValidateOptions",
			"com.ibm.ccd.element.interfaces.IContainer");
runJavaMethod(objEntryPopulator, mRecalculateValidateOptions, ctg);

// Get primary key attribute path
var ctgSpec = ctg.getCtgSpec();
var pkNode = ctgSpec.getPrimaryKeyNode();
var pkNodePath = "/" + pkNode.getNodePath();


var my_parser = new CSVParser(in);

var bDone = false;
var lineNumber = 0;
var lineToken = "";
while ( ! bDone )
{
    var f;
    catchError (f)
    {
        var item = null;
        var attrs = my_parser.splitLine();
        var hmReplace = [];
        bDone = (null == attrs);
        if ( ! bDone )
        {
            var g;
            var attr_name;
            catchError (g) {
                lineNumber = lineNumber +1;
                var item = null;
                var hasRelationshipAttrib = false;
                // loop over fields setting the appropriate attribute
                // using the name-value pair in each field
                for (var i = 0; i < attrs.size(); i++ )
                {
                    var attr_name_value = attrs[i].parseDelim("|");
                    attr_name = replaceCSVDefaults(attr_name_value[0],defaultMessageMap);
                    var attr_value = attr_name_value[1];
                    lineToken = attr_name_value[0]+"|"+attr_name_value[1];
                    getLogger("import.rel").loggerDebug("traitement de attr_name :"+attr_name+" / attr_value : "+ attr_value);
                    if ( null != attr_name && "" != attr_name && null != attr_value && attr_name != "CATEGORY")
                    {
						if ( (attr_name == (pkNodePath + "#0")) || (attr_name == pkNodePath) )
                        {
                    		getLogger("import.rel").loggerDebug("Traitement de PK["+attr_value+"]");
                            item = ctg.getCtgItemByPrimaryKey(attr_value);
                            if (item == null)
                            {
                    			getLogger("import.rel").loggerError("Cannot get item["+attr_value+"]");                            
								throwError("Cannot get item["+attr_value+"]");
                            }
                        }
						else if ( attr_value == "RELATIONSHIP_INFO" ) {	
                            if (item == null)
                            {
                    			getLogger("import.rel").loggerError("Cannot get item relationship prior item pk");                            
								throwError("Cannot get item --> relationship prior item pk");
                            }
										                    
                        	var src;
                        	var tgt;
                        	var original_attr_name = attr_name;
                        	forEachHmElement(hmReplace, src, tgt) {
                             	attr_name = replaceString(attr_name, src, tgt);
                       		}
                        	getLogger("import.rel").loggerInfo("attr_name ==> "+attr_name);

                            //521 codebase also exports blank value of grouping node.
                            //if you set any value on grouping node then 5.3 codebase complains.
                            //so skipping all grouping node. 
                            var seperatorIndex = attr_name.lastIndexOf("/");
                            var multivalueIndex = attr_name.lastIndexOf("#");
                            if(multivalueIndex > seperatorIndex)
                            {
                            	// getLogger("import.rel").loggerInfo("dans le if : "+multivalueIndex+" > "+seperatorIndex);
                                var tempAttrPath = attr_name.substring(0,multivalueIndex);
                                var entryNode = item.getRootEntryNode().getEntryNode(tempAttrPath);
                                if(entryNode != null)
                                {
                                    node = entryNode.getNodeFromEntryNode();
                                    var type = node.getNodeAttributeValue("TYPE");
                                    // getLogger("import.rel").loggerInfo("type : "+type);
                                    if(type == "GROUPING" )
                                    {
                                        continue;
                                    }
                                }
                            }
                            var correct_path = "/";
                            while(true) { 
                                var e;
                                catchError(e) {
//out.writeln("ATTRM["+attr_name+"]<--["+attr_value+"]");
                            		var relatedCatalogName = attr_name_value[2];
                            		var relatedItemPrimaryKey = attr_name_value[3];
	                            	getLogger("import.rel").loggerInfo("setEntryRelationshipAttrib : attr_name => "+attr_name +" , attr_value => "+relatedCatalogName+"|"+relatedItemPrimaryKey);

                            		var relatedCatalog = relatedCatalogs[relatedCatalogName];

                            		if ( null == relatedCatalog )
                            		{
                                		relatedCatalog = getCtgByName(relatedCatalogName);
                                		relatedCatalogs[relatedCatalogName] = relatedCatalog;
                            		}

                            		if ( null != relatedCatalog && null != relatedItemPrimaryKey )
                            		{
                                		hasRelationshipAttrib = true;
                                		item.setEntryRelationshipAttrib(attr_name, relatedCatalog, relatedItemPrimaryKey);	
                            		}
                                }
                                if (e != null) {
                                    getLogger("import.rel").loggerInfo("erreur e = "+e);
                                    var next = "";
                                    while (correct_path != (attr_name+"/"))
                                    {
										getLogger("import.rel").loggerInfo("while : correct_path =>"+correct_path);
                                        next = substring(attr_name, 
                                                         attr_name.indexOf(correct_path)+correct_path.length(),
                                                         attr_name.length());
										getLogger("import.rel").loggerInfo("while : next          =>"+next);
                                        if (next.indexOf("/") != -1) {
                                            next = substring(next, 0, next.indexOf("/"));
                                        }
                                        getLogger("import.rel").loggerInfo("while : next apres if =>"+next);
										//out.writeln("ATTRNAME["+attr_name+"] CORRECTPATH["+correct_path+"]  NEXT["+next+"]");                                        
										//getLogger("import.rel").loggerError("ATTRNAME["+attr_name+"] CORRECTPATH["+correct_path+"]  NEXT["+next+"]");                                        
                                        if ((next.contains("#") && (! (next.endsWith("#0"))))) {
                                            getLogger("import.rel").loggerInfo("dans le if ... ");                                        
                                            // possible problem coming from not - existing sibling
                                            var aNext =  next.parseDelim("#");
                                            var tmp_correct_path = correct_path + aNext[0];
                                            var count = checkInt(aNext[1], 0);
                                            while ((count >= 0) && (item.getRootEntryNode().getEntryNode(tmp_correct_path + "#" + count) == null)) {
											// out.writeln("ATTRM["+attr_name+"]<--["+attr_value+"] trying ["+tmp_correct_path + "#" + count+"]");                                                
											// getLogger("import.rel").loggerError("ATTRM["+attr_name+"]<--["+attr_value+"] trying ["+tmp_correct_path + "#" + count+"]");                                                
                                                count--;
                                            }
                                            // count is now equal to the last existing occurrence
                                            // next valid occurence is one above
                                            count++;
                                            if (count != checkInt(aNext[1], 0)) {
                                                tmp_correct_path = tmp_correct_path + "#" + count;
                                                attr_name = replaceString(attr_name, correct_path + next, tmp_correct_path);
                                                correct_path = tmp_correct_path + "/"; 
                                                // give another try
                                                break;
                                            }
                                        }
                                        
                                        correct_path = correct_path + next + "/";
                                        getLogger("import.rel").loggerInfo("a la fin du while : correct_path = "+correct_path+" , next = "+next);
                                    }
                                    if (next == "")
                                    {
                                        throwError("Some other Error " + correct_path);
                                    }
                                    continue;
                                }
                                if (correct_path != "/")
                                {
                                    // found a good replacement for the attrname.
                                    var count = correct_path.parseDelim("/").size() - 1;
                                    var w = 1;
                                    var aIncorrectPath = original_attr_name.parseDelim("/");
                                    var incorrect_path = "/";
                                    for (w = 1; w < count; w++)
                                    {
                                        incorrect_path = incorrect_path + aIncorrectPath[w] + "/"; 
                                    }
                                    hmReplace = [];
                                    hmReplace[incorrect_path] = correct_path;
//out.writeln("Replacing ["+incorrect_path+"] by ["+correct_path+"]");

                                }
                                break;
                            }
//out.writeln("Continue with Attr Settings");

                            var attr_entry_node = item.getRootEntryNode().getEntryNode(attr_name);
                            if(attr_entry_node != null)
                            {
                                var attr_node_type = attr_entry_node.getNodeFromEntryNode().getNodeAttributeValue("TYPE");
								var multiOccur = (attr_entry_node.getNodeFromEntryNode().getNodeAttributeValue("MAX_OCCURRENCE") > 1);
								if(multiOccur == true && attr_name.contains("#") == false)
								{
									attr_name = attr_name + "#0";
								}                                
                            }
                        }
                    }
                }
                if (hasRelationshipAttrib) {
                	getLogger("import.rel").loggerDebug("saving item "+item.getPrimaryKey());
                	var res = item.saveCtgItem();
                	if(res !=null && res.getGlobalErrors().size() >0){
                		var tbl = res.getGlobalErrors();
                		for(var err=0;err<res.getGlobalErrors().size();err++){
							getLogger("import.rel").loggerError(tbl[err].getValidationErrorMsg());
						}
                	}
                	getLogger("import.rel").loggerDebug("item saved ");
                } else {
                	getLogger("import.rel").loggerDebug("Item "+item.getPrimaryKey() + "Has no relationship");
                }
            }

            if (g != null)
            {
            var exceptionStr;
            	if (item != null) {
                	 exceptionStr = "Error building entries while processing catalog ["+ctg+"] at line number["+lineNumber+"] for token["+lineToken+"]  attr_name["+attr_name+"] pk[" + checkString(item.getPrimaryKey(),"null") + "] with error "+g;
                }
                else
                {
                	 exceptionStr = "Error building entries while processing catalog ["+ctg+"] at line number["+lineNumber+"] for token["+lineToken+"]  attr_name["+attr_name+"]  with error "+g;
                }
//out.writeln(exceptionStr);
                //return null;
                getLogger("import.rel").loggerError("**************************************************************************");
                getLogger("import.rel").loggerError(exceptionStr);
                getLogger("import.rel").loggerError("**************************************************************************");
            }
        }
    }

    if (f != null)
    {
//out.writeln("ERROR parsing CSV file "+f);
        //return null;
        throwError("ERROR parsing CSV file "+f);
    }
}
